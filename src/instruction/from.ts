import * as Computed from '../compute';
import { control, Controller } from '../controller';
import { issues } from '../issues';
import { Stateful } from '../model';
import { pendingValue } from '../suspense';
import { apply } from './apply';

export const Oops = issues({
  BadComputedSource: (model, property, got) =>
    `Bad from-instruction provided to ${model}.${property}. Expects an arrow-function or a Model as source. Got ${got}.`,

  PeerNotAllowed: (model, property) =>
    `Attempted to use an instruction result (probably use or tap) as computed source for ${model}.${property}. This is not possible.`
})

declare namespace from {
  type Function<T, O=any> = (this: O, on: O) => T;
  type Factory<T, O=any> = (key: string) => Function<T, O>;
  type Getter = (controller: Controller, key: string) => any;
}

/**
 * Implement a computed value; output will be generated by provided function.
 *
 * @param source - Source model from which computed value will be a subscriber.
 * @param compute - Compute function. Bound to a subscriber-proxy of source, returns output value. Will update automatically as input values change.
 * @param suspend - Value will throw suspense when evaulating to undefined.
 */
function from <R, T> (source: T, compute: (this: T, on: T) => R | void, suspend: true): R;
function from <R, T> (source: T, compute: (this: T, on: T) => R, suspend?: boolean): R;

/**
 * Implement a computed value; output is returned by function from provided factory.
 *
 * @param compute - Factory function to generate a getter to subscribe dependancies.
 * @param suspend - Value will throw suspense when evaulating to undefined.
 */
function from <R, T> (compute: (property: string) => (this: T, state: T) => R | void, suspend: true): R;
function from <R, T> (compute: (property: string) => (this: T, state: T) => R, suspend?: boolean): R;

function from<R, T>(
  source: from.Factory<T> | Stateful,
  setter?: from.Function<T> | boolean,
  arg?: boolean): R {

  return apply(
    function from(key){
      const { subject } = this;

      let getSource: () => Controller;
      let getter: from.Getter | undefined;

      if(arg === true || setter === true)
        getter = pendingValue;

      if(typeof setter == "boolean")
        setter = undefined;

      // Easy mistake, using a peer, will always be unresolved.
      if(typeof source == "symbol")
        throw Oops.PeerNotAllowed(subject, key);

      // replace source controller in-case it is different
      if(typeof source == "object")
        getSource = () => control(source);

      // specifically an arrow function (getter factory)
      else if(!source.prototype){
        setter = source.call(subject, key);
        getSource = () => this;
      }

      // Regular function is too ambiguous so not allowed.
      else
        throw Oops.BadComputedSource(subject, key, source);

      Computed.prepare(this, key, getSource, setter!, getter);
    }
  )
}

export { from }