import { getRecursive, Parent } from '../children';
import { Control, control } from '../control';
import { issues } from '../helper/issues';
import { Callback } from '../helper/types';
import { Model } from '../model';
import { Subscriber } from '../subscriber';
import { suspend } from '../suspense';
import { add } from './add';

export const Oops = issues({
  Required: (expects, child) => 
    `New ${child} created standalone but requires parent of type ${expects}. Did you remember to create via use(${child})?`,

  Unexpected: (expects, child, got) =>
    `New ${child} created as child of ${got}, but must be instanceof ${expects}.`,

  PeerNotAllowed: (model, property) =>
    `Attempted to use an instruction result (probably use or tap) as computed source for ${model}.${property}. This is not possible.`,

  Failed: (parent, property, initial) =>
    `An exception was thrown while ${initial ? "initializing" : "refreshing"} [${parent}.${property}].`
});

declare namespace get {
  type Function<T, S = any> = (this: S, on: S) => T;
  type Factory<R, T> = (this: T, property: string, on: T) => Function<R, T>;
}

/**
 * Implement a computed value; output will be generated by provided function.
 *
 * @param source - Source model from which computed value will be a subscriber.
 * @param compute - Compute function. Bound to a subscriber-proxy of source, returns output value. Will update automatically as input values change.
 * @param suspend - Value will throw suspense when evaulating to undefined.
 */
function get <R, T> (source: T, compute: (this: T, on: T) => R, suspend: true): Exclude<R, undefined>;
function get <R, T> (source: T, compute: (this: T, on: T) => R, suspend?: boolean): R;

/**
 * Fetches and assigns the controller which spawned this host.
 * When parent assigns an instance via `use()` directive, it
 * will be made available to child upon this request.
 *
 * @param Type - Type of controller compatible with this class. 
 * @param required - Throw if controller is created independantly.
 */
function get <T extends Model> (Type: Model.Type<T>, required?: true): T;
function get <T extends Model> (Type: Model.Type<T>, required: boolean): T | undefined;

/**
 * Implement a computed value; output is returned by function from provided factory.
 *
 * @param compute - Factory function to generate a getter to subscribe dependancies.
 * @param suspend - Value will throw suspense when evaulating to undefined.
 */
function get <R, T> (compute: (property: string, on: T) => (this: T, state: T) => R, suspend: true): Exclude<R, undefined>;
function get <R, T> (compute: (property: string, on: T) => (this: T, state: T) => R, suspend?: boolean): R;
 
function get<R, T extends Model>(
  arg0: get.Factory<R, T> | Model.Type<T> | T,
  arg1?: get.Function<T> | boolean,
  arg2?: boolean): R {

  return add(
    function get(key){
      const { subject, state } = this;

      // Easy mistake, using a peer, will always be unresolved.
      if(typeof arg0 == "symbol")
        throw Oops.PeerNotAllowed(subject, key);

      if(Model.isTypeof(arg0)){
        const value = Parent.get(subject) as T;
        const expected = arg0.name;

        if(!value){
          if(arg1 !== false)
            throw Oops.Required(expected, subject);
        }
        else if(!(value instanceof arg0))
          throw Oops.Unexpected(expected, subject, value);

        this.state.set(key, value);

        return getRecursive(key, this)
      }

      let getter: () => any;
      const required = arg1 === true || arg2 === true;

      const init = () => {
        let source = this;
        let setter: get.Function<T, any>;
        const from = arg0 as get.Factory<R, T> | T;
 
        if(typeof from == "function"){
          setter = from.call(subject, key, subject) as any;
        }
        else if(typeof arg1 == "function"){
          // replace source controller in-case it is different
          source = control(from);
          setter = arg1;
        }
        else
          throw new Error(`Factory argument cannot be ${arg1}`);

        let sub: Subscriber;
        let order = ORDER.get(this)!;
        let pending = KEYS.get(this)!
      
        if(!order)
          ORDER.set(this, order = new Map());
      
        if(!pending)
          KEYS.set(this, pending = new Set());
      
        const compute = (initial: boolean) => {
          try {
            return setter.call(sub.proxy, sub.proxy);
          }
          catch(err){
            Oops.Failed(subject, key, initial).warn();
            throw err;
          }
        }
      
        const refresh = () => {
          let value;
      
          try {
            value = compute(false);
          }
          catch(e){
            console.error(e);
          }
          finally {
            if(state.get(key) !== value){
              state.set(key, value);
              this.update(key);
              return value;
            }
          }
        }
      
        const create = () => {
          sub = new Subscriber(source, (_, source) => {
            if(source !== this)
              refresh();
            else
              pending.add(refresh);
          });
      
          sub.watch.set(key, false);
      
          try {
            const value = compute(true);
            state.set(key, value);
            return value;
          }
          catch(e){
            throw e;
          }
          finally {
            sub.commit();
            order.set(refresh, order.size);
          }
        }
      
        getter = () => {
          if(pending.has(refresh)){
            pending.delete(refresh)
            refresh();
          }
      
          const value = sub ? state.get(key) : create();
      
          if(value === undefined && required)
            throw suspend(this, key);
      
          return value;
        }
      
        INFO.set(refresh, key);
      }

      state.set(key, undefined);

      if(typeof arg0 == "function" && required)
        init();

      return () => {
        if(!getter)
          init();

        return getter();
      }
    }
  )
}

const INFO = new WeakMap<Callback, string>();
const KEYS = new WeakMap<Control, Set<Callback>>();
const ORDER = new WeakMap<Control, Map<Callback, number>>();

export function flush(control: Control){
  const pending = KEYS.get(control);

  if(!pending || !pending.size)
    return;

  const priority = ORDER.get(control)!;

  while(pending.size){
    let compute!: Callback;

    for(const item of pending)
      if(!compute || priority.get(item)! < priority.get(compute)!)
        compute = item;

    pending.delete(compute);

    const key = INFO.get(compute)!;

    if(!control.frame.has(key))
      compute();
  }

  pending.clear();
}

export { get }