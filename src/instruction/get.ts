import { control } from '../control';
import { issues } from '../helper/issues';
import { Model } from '../model';
import { mayRetry } from '../suspense';
import { add } from './add';
import { computeMode } from './get.compute';

export const Oops = issues({
  PeerNotAllowed: (model, property) =>
    `Attempted to use an instruction result (probably use or tap) as computed source for ${model}.${property}. This is not possible.`,

  ComputeFailed: (model, key) =>
    `Generating initial value for ${model}.${key} failed.`,

  Failed: (parent, property, initial) =>
    `An exception was thrown while ${initial ? "initializing" : "refreshing"} [${parent}.${property}].`
});

declare namespace get {
  type Function<T, S = any> = (this: S, on: S) => T;
}

/**
 * Implement a computed value; output will be generated by provided function.
 *
 * @param source - Source model from which computed value will be a subscriber.
 * @param compute - Compute function. Bound to a subscriber-proxy of source, returns output value. Will update automatically as input values change.
 * @param suspend - Value will throw suspense when evaulating to undefined.
 */
function get <R, T> (source: T, compute: (this: T, on: T) => R, suspend: true): Exclude<R, undefined>;
function get <R, T> (source: T, compute: (this: T, on: T) => R, suspend?: boolean): R;

/**
 * Implement a computed value; output is returned by function from provided factory.
 *
 * @param compute - Factory function to generate a getter to subscribe dependancies.
 * @param suspend - Value will throw suspense when evaulating to undefined.
 */
function get <R, T> (compute: (property: string, on: T) => (this: T, state: T) => R, suspend: true): Exclude<R, undefined>;
function get <R, T> (compute: (property: string, on: T) => (this: T, state: T) => R, suspend?: boolean): R;
 
function get<R, T>(
  arg0: ((this: T, key: string, thisArg: T) => get.Function<R, T>) | Model,
  arg1?: get.Function<T> | boolean,
  arg2?: boolean): R {

  return add(
    function get(key){
      const { subject } = this;
      const required = arg1 === true || arg2 === true;

      let getter: () => any;

      // Easy mistake, using a peer, will always be unresolved.
      if(typeof arg0 == "symbol")
        throw Oops.PeerNotAllowed(subject, key);

      this.state.set(key, undefined);

      const init = (): any => {
        let source = this;
        let setter: get.Function<T, any>;
 
        if(typeof arg0 == "function"){
          setter = mayRetry(arg0.bind(subject, key, subject));
        }
        else if(typeof arg1 == "function"){
          // replace source controller in-case it is different
          source = control(arg0);
          setter = arg1;
        }
        else
          throw new Error(`Factory argument cannot be ${arg1}`);

        getter = computeMode(this, source, setter, key, required);
      }

      if(typeof arg0 == "function" && required)
        try {
          init();
        }
        catch(err){
          Oops.ComputeFailed(subject, key).warn();
          throw err;
        }

      return () => {
        if(!getter)
          init();

        return getter();
      }
    }
  )
}

export { get }