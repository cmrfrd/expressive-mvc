import { getParent } from '../children';
import { Control, controller } from '../control';
import { issues } from '../helper/issues';
import { Callback } from '../helper/types';
import { Model } from '../model';
import { Subscriber } from '../subscriber';
import { add } from './add';

export const Oops = issues({
  PeerNotAllowed: (model, property) =>
    `Attempted to use an instruction result (probably use or get) as computed source for ${model}.${property}. This is not allowed.`,

  Failed: (parent, property, initial) =>
    `An exception was thrown while ${initial ? "initializing" : "refreshing"} [${parent}.${property}].`,

  Required: (expects, child) => 
    `New ${child} created standalone but requires parent of type ${expects}. Did you remember to create via use(${child})?`,
});

declare namespace get {
  type Function<T, S = any> = (this: S, on: S) => T;

  type Factory<R, T> = (this: T, property: string, on: T) => Function<R, T>;

  type FindFunction<T extends Model = Model> =
    (type: typeof Model, relativeTo: Model, required: boolean) => Source<T>;

  type Source<T extends Model = Model> =
    (callback: (x: T) => void) => void;

  /** Assign fetch algorithm for get instruction. */
  export let using: (fn: FindFunction) => typeof get;
}

/**
 * Fetches and assigns the controller which spawned this host.
 * When parent assigns an instance via `use()` directive, it
 * will be made available to child upon this request.
 *
 * @param Type - Type of controller compatible with this class. 
 * @param required - Throw if controller is created independantly.
 */
function get <T extends Model> (Type: Model.Type<T>, required?: true): T;
function get <T extends Model> (Type: Model.Type<T>, required: boolean): T | undefined;

function get <R, T extends Model> (Type: Model.Type<T>, compute: (this: T, on: T) => R): Exclude<R, undefined>;
function get <R, T extends Model> (Type: Model.Type<T>, compute: (this: T, on: T) => R): R;

/**
 * Implement a computed value; output will be generated by provided function.
 *
 * @param source - Source model from which computed value will be a subscriber.
 * @param compute - Compute function. Bound to a subscriber-proxy of source, returns output value. Will update automatically as input values change.
 */
function get <R, T> (source: T, compute: (this: T, on: T) => R): Exclude<R, undefined>;
function get <R, T> (source: T, compute: (this: T, on: T) => R): R;

/**
 * Implement a computed value; output is returned by function from provided factory.
 *
 * @param compute - Factory function to generate a getter to subscribe dependancies.
 */
function get <R, T> (compute: (property: string, on: T) => (this: T, state: T) => R): Exclude<R, undefined>;
function get <R, T> (compute: (property: string, on: T) => (this: T, state: T) => R): R;
 
function get<R, T extends Model>(
  this: get.FindFunction,
  arg0: get.Factory<R, T> | (Model.Type<T> & typeof Model) | T,
  arg1?: get.Function<R, T> | boolean): R {

  const fetch = this || getParentForGetInstruction;

  return add(
    function get(key){
      let { subject } = this;

      if(typeof arg0 == "symbol")
        throw Oops.PeerNotAllowed(subject, key);

      let source: get.Source = cb => cb(subject);

      if(arg0 instanceof Model)
        subject = arg0;

      else if(Model.isTypeof(arg0))
        source = fetch(arg0, subject, arg1 !== false)!;

      else if(typeof arg0 == "function")
        arg1 = arg0.call(subject, key, subject);

      return typeof arg1 == "function"
        ? getComputed(key, this, source, arg1)
        : getRecursive(key, this, source, arg1);
    }
  )
}

function getParentForGetInstruction<T extends Model>(
  type: Model.Type<T>,
  relativeTo: Model,
  required: boolean
): get.Source {
  const item = getParent(relativeTo, type);

  return callback => {
    if(item)
      callback(item);
    else if(required)
      throw Oops.Required(type.name, relativeTo);
  };
}

function getRecursive(
  key: string,
  parent: Control,
  source: get.Source,
  required?: boolean){

  const context = new WeakMap<Subscriber, {} | undefined>();
  const { state } = parent;
  let waiting: boolean;

  source((got) => {
    state.set(key, got);

    if(waiting)
      parent.update(key);
  });

  waiting = true;

  function create(local: Subscriber){
    let reset: Callback | undefined;

    local.follow(key, init);
    init();

    function init(){
      if(reset)
        reset();

      const value = state.get(key);

      if(value && controller(value)){
        const child = new Subscriber(value, local.onUpdate);

        if(local.active)
          child.commit();

        local.dependant.add(child);
        context.set(local, child.proxy);

        reset = () => {
          child.release();
          local.dependant.delete(child);
          context.set(local, undefined);
          reset = undefined;
        }
      }
    }
  }

  return (local: Subscriber | undefined) => {
    const value = state.get(key);

    if(!value && required !== false)
      parent.waitFor(key);

    if(!local)
      return value;

    if(!context.has(local))
      create(local);

    return context.get(local);
  }
}

function getComputed<T>(
  key: string,
  parent: Control,
  source: get.Source,
  setter: get.Function<T, any>){

  const { state } = parent;

  let local: Subscriber | undefined;
  let active: boolean;
  let isAsync: boolean;

  let order = ORDER.get(parent)!;
  let pending = KEYS.get(parent)!;

  if(!order)
    ORDER.set(parent, order = new Map());

  if(!pending)
    KEYS.set(parent, pending = new Set());

  INFO.set(compute, key);

  function compute(initial?: boolean){
    let next: T | undefined;

    try {
      next = setter.call(local!.proxy, local!.proxy);
    }
    catch(err){
      Oops.Failed(parent.subject, key, initial).warn();

      if(initial)
        throw err;
      
      console.error(err);
    }

    if(next !== state.get(key)){
      state.set(key, next);

      if(!initial || isAsync)
        parent.update(key);
    }
  }

  function connect(model: Model){
    local = new Subscriber(model, (_, control) => {
      if(control !== parent)
        compute();
      else
        pending.add(compute);
    });

    local.watch.set(key, false);

    try {
      compute(true);
    }
    finally {
      local.commit();
      order.set(compute, order.size);
    }
  }

  return () => {
    if(!active){
      active = true;
      source(connect);
      isAsync = true;
    }
    
    if(!local)
      parent.waitFor(key);

    if(pending.delete(compute))
      compute();

    return state.get(key);
  }
}

const INFO = new WeakMap<Callback, string>();
const KEYS = new WeakMap<Control, Set<Callback>>();
const ORDER = new WeakMap<Control, Map<Callback, number>>();

function flush(control: Control){
  const pending = KEYS.get(control);

  if(!pending || !pending.size)
    return;

  const priority = ORDER.get(control)!;

  while(pending.size){
    let compute!: Callback;

    for(const item of pending)
      if(!compute || priority.get(item)! < priority.get(compute)!)
        compute = item;

    pending.delete(compute);

    const key = INFO.get(compute)!;

    if(!control.frame.has(key))
      compute();
  }

  pending.clear();
}

function using(fn: get.FindFunction){
  return Object.assign(get.bind(fn), { using });
}

get.using = using;

export {
  flush,
  get
}